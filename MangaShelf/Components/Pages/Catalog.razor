@page "/catalog"
@using MangaShelf.BL.Dto
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using MudBlazor.Services

@inject IVolumeService VolumeService
@inject ICacheService CacheService
@inject IUiLocalizationService Localizer
@inject ProtectedLocalStorage ProtectedLocalStorage

<MudPaper Class="p-4 mb-4" Elevation="3" Style="background-color: transparent">
    <MudStack Row>

        <MudAutocomplete T="string" Label="@Localizer["Search"]" @bind-Value="Search" SearchFunc="@Search2" Variant="Variant.Outlined" Clearable
                         ResetValueOnEmptyText="true"
                         SelectValueOnTab="true" CoerceValue="true"
                         AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Primary" />


        <MudButton Variant="Variant.Text" OnClick="ToggleFilters"><MudIcon Icon="@Icons.Material.Rounded.FilterAlt"></MudIcon>@Localizer["Filter"]</MudButton>
        <MudButton Variant="Variant.Text" OnClick="ResetFilters"><MudIcon Icon="@Icons.Material.Rounded.FilterAltOff"></MudIcon>@Localizer["Reset"]</MudButton>
    </MudStack>
    @if (FilterToggle)
    {
        <MudStack Row Class="pt-4" Elevation="0" Style="background-color: transparent" AlignItems="AlignItems.Center" Justify="Justify.Center">
            <MudSelect Label="@Localizer["ResultPerPage"]" @bind-Value="PageSize" FitContent="true">
                <MudSelectItem Value="24"></MudSelectItem>
                <MudSelectItem Value="48"></MudSelectItem>
                <MudSelectItem Value="96"></MudSelectItem>
                <MudSelectItem Value="0">@Localizer["All"]</MudSelectItem>
            </MudSelect>

            <MudChipSet @bind-SelectedValues="SelectedReleaseFilter" SelectionMode="SelectionMode.MultiSelection" Variant="Variant.Text" Color="Color.Info">
                <MudChip Value="ReleaseFilter.Preorder" Text="@Localizer[ReleaseFilter.Preorder.ToString()]" />
                <MudChip Value="ReleaseFilter.Released" Text="@Localizer[ReleaseFilter.Released.ToString()]" />
            </MudChipSet>

        </MudStack>
    }
</MudPaper>


@if (_loading != true)
{
    @if (_totalPages > 1)
    {
        <div class="d-flex flex-column align-center mb-8">
            <MudPagination Color="Color.Primary" ShowFirstButton="true" ShowLastButton="true" Count="_totalPages" @bind-Selected="SelectedPage" Class="mt-4" />
        </div>
    }
    <MudGrid Justify="@justification" Spacing="6">
        @foreach (var volume in volumes)
        {
            <MudItem xs="6" sm="3" md="2" lg="2">
                <SmallCard Volume="@volume" />
            </MudItem>
        }
    </MudGrid>

    @if (_totalPages > 1)
    {
        <div class="d-flex flex-column align-center mb-8">
            <MudPagination Color="Color.Primary" ShowFirstButton="true" ShowLastButton="true" Count="_totalPages" @bind-Selected="SelectedPage" Class="mt-4" />
        </div>
    }
}



@code
{
    private bool _loading;

    private IReadOnlyCollection<ReleaseFilter> _selectedReleaseFilter = [ReleaseFilter.Released, ReleaseFilter.Preorder];
    private IReadOnlyCollection<ReleaseFilter> SelectedReleaseFilter
    {
        get => _selectedReleaseFilter;
        set
        {
            _selectedReleaseFilter = value;
            SelectedPage = 1;
            _ = ReloadVolumes();
        }
    }

    private bool _filterToggle;
    private bool FilterToggle
    {
        get => _filterToggle; set
        {
            _filterToggle = value;
            ProtectedLocalStorage.SetAsync(nameof(FilterToggle), value);
        }
    }

    private int _totalPages;

    private string? _search = string.Empty;
    private string? Search
    {
        get => _search;
        set
        {
            if (_search != value)
            {
                _search = value;
                if (_search is null || _search.Length > 1)
                {
                    SelectedPage = 1;
                    _ = ReloadVolumes();
                }
            }
        }
    }

    private int _pageSize = 24;
    private int PageSize
    {
        get => _pageSize;
        set
        {
            if (value != _pageSize)
            {
                _pageSize = value;
                SelectedPage = 1;
                _ = ReloadVolumes();
            }
        }
    }


    private int _selectedPageValue = 1;
    private int SelectedPage
    {
        get => _selectedPageValue;
        set
        {
            if (_selectedPageValue != value)
            {
                _selectedPageValue = value;
                _ = ReloadVolumes();
            }
        }
    }


    Justify justification = Justify.FlexStart;

    IEnumerable<CardVolumeDto> volumes = Enumerable.Empty<CardVolumeDto>();

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {


        await base.OnAfterRenderAsync(firstRender);
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadFromStorage();
        await ReloadVolumes();
    }

    private async Task ReloadVolumes()
    {
        _loading = true;
        StateHasChanged();

        var releaseFilter = ReleaseFilter.None;
        if (SelectedReleaseFilter != null && SelectedReleaseFilter.Count == 1)
        {
            releaseFilter = SelectedReleaseFilter.First();
        }

        Common.FilterOptions paginationOption = new() { PageNumber = SelectedPage, PageSize = PageSize, Search = Search, ReleaseFilter = releaseFilter };

        (volumes, _totalPages) = await VolumeService.GetAllVolumesAsync(paginationOption);

        await SaveToStorage();

        _loading = false;
        StateHasChanged();
    }

    private async Task SaveToStorage()
    {
        try
        {
            await ProtectedLocalStorage.SetAsync(nameof(SelectedPage), SelectedPage);
            await ProtectedLocalStorage.SetAsync(nameof(PageSize), PageSize);

            if (Search != null)
            {
                await ProtectedLocalStorage.SetAsync(nameof(Search), Search);
            }

            await ProtectedLocalStorage.SetAsync(nameof(SelectedReleaseFilter), SelectedReleaseFilter);

        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }

    private async Task LoadFromStorage()
    {
        _selectedPageValue = await GetFromStorage<int>(nameof(SelectedPage));
        _pageSize = await GetFromStorage<int>(nameof(PageSize));
        _search = await GetFromStorage<string>(nameof(Search));
        _filterToggle = await GetFromStorage<bool>(nameof(FilterToggle));
        _selectedReleaseFilter = await GetFromStorage<IReadOnlyCollection<ReleaseFilter>>(nameof(SelectedReleaseFilter));
    }

    private async Task<T> GetFromStorage<T>(string key)
    {
        try
        {
            var result = await ProtectedLocalStorage.GetAsync<T>(key);
            if (result.Success && result.Value is not null)
            {
                return result.Value;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }

        return default!;
    }

    private void ToggleFilters()
    {
        FilterToggle = !FilterToggle;
    }

    private void ResetFilters()
    {
        Search = string.Empty;
        SelectedPage = 1;
        _ = ReloadVolumes();
    }

    private IEnumerable<string> autocomplete;

    private async Task<IEnumerable<string>> Search2(string value, CancellationToken token)
    {
        // In real life use an asynchronous function for fetching data from an api.
        if (autocomplete is null)
        {
            autocomplete = CacheService.GetSearchAutoComplete();
        }

        // if text is null or empty, don't return values (drop-down will not open)
        if (string.IsNullOrEmpty(value))
            return new string[0];

        return autocomplete
        .Where(x => x.Contains(value, StringComparison.InvariantCultureIgnoreCase))
        .OrderByDescending(x => CalculateMatchScore(x, value))
        .ToList();
    }

    private double CalculateMatchScore(string item, string searchValue)
    {
        // Case-insensitive comparison
        var normalizedItem = item.ToLowerInvariant();
        var normalizedSearch = searchValue.ToLowerInvariant();

        // Exact match gets highest score
        if (normalizedItem.Equals(normalizedSearch))
            return 1.0;

        // Starts with match gets high score
        if (normalizedItem.StartsWith(normalizedSearch))
            return 0.9 - (0.001 * (normalizedItem.Length - normalizedSearch.Length));

        // Contains match gets lower score based on position and length
        int position = normalizedItem.IndexOf(normalizedSearch);

        // Score decreases as position increases and as length difference increases
        return 0.5 - (0.01 * position) - (0.001 * (normalizedItem.Length - normalizedSearch.Length));
    }
}